[
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "dfd191d3-bf26-40ef-a750-bb45bb94c5f7",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC001-Chef de Chantier records attendance as Présent with an optional avance and saves successfully",
    "description": "Verifies a Chef de Chantier can create a daily attendance entry for a worker, optionally add an avance amount, and receive a visible success confirmation after saving.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin email and password fields and click the 'Connexion Administrateur' button to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gestion Employés' item in the left sidebar to navigate to the employee/attendance page (target: /feuille-presence).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gestion Employés' link in the left sidebar to navigate to the employee/attendance page (expect URL to contain /feuille-presence).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the attendance sheet for the 'Chef de Chantier' by clicking the 'Présence' element on that employee card (expect navigation to /feuille-presence).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Profil →' link in the employee panel to open the full profile / attendance sheet (expect URL to contain '/feuille-presence').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Profil →' link in the profile panel (index 1835) to open the full profile/attendance page (expect URL to contain '/feuille-presence').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the attendance date using the date picker (input index 2349) so the attendance sheet for that date will be shown/used.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div[2]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-16')\n        \n        # -> Click 'Retour aux employés' to return to employee list and attempt to open the presence/attendance view from there (click element index 2548).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employee 'Historique' tab to reveal presence/attendance controls, then search for the 'Ajouter' control to add an attendance row.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to the attendance sheet (/feuille-presence) to access add-row control; use direct navigation since no relevant clickable element revealed the attendance page.\n        await page.goto(\"http://localhost:3000/feuille-presence\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Informations' tab/button (index 3166) to reveal profile sections and look for attendance/add-row controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Avances' tab in the employee profile to look for add-row or save controls (may reveal add/avance controls).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employees list by clicking 'Retour aux employés' (index 3225), wait for the page to load, then search the page for the 'Ajouter' control (or any attendance add/save controls). If found, proceed to add a row; otherwise report controls not found.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Avances tab (index 3169) to ensure advances section is active, then scroll the main profile area to reveal any add-row/controls (look for 'Ajouter'/'Enregistrer' or floating add buttons). If visible, extract page text near matches and return candidate element indices.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254995146523//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.635Z",
    "modified": "2026-02-16T15:16:35.376Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "d756fa8d-a865-493d-95cb-0c3b347f1f2d",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC002-Chef de Chantier completes required fields for a new row and confirms success after Save",
    "description": "Verifies that selecting a worker, setting status to Présent, and saving shows a visible success confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field, fill the password field, and click the 'Connexion Administrateur' button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open employee management menu to find the 'Feuille de Présence' page by clicking 'Gestion Employés' in the sidebar.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Feuille de Présence' page by clicking the relevant menu/link under 'Gestion Employés' in the sidebar.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the attendance editor for a worker by clicking the 'Présence' control on an employee card (first employee's Présence element).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employee edit form by clicking 'Modifier' on the right-side collaborator panel so the presence/status field and Save control become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the employee edit modal so the presence panel is accessible, then set status to 'Présent', save, and verify the visible success confirmation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit modal (Annuler) so the presence panel is accessible, then open the worker's Présence control to set status.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employee edit modal to access the presence/status field (click 'Modifier'), then set status to 'Présent', save, and verify a visible success confirmation. Immediate action: click the 'Modifier' button in the collaborator panel.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit modal so the presence panel is accessible, then open the employee's 'Présence' control so the status selector can be set to 'Présent'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the attendance editor within the collaborator drawer (click the 'Présence' card) so the status selector becomes available, then set status to 'Présent', save, and verify the visible success confirmation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Switch to the 'Vue Tableau' (table view) to reveal attendance controls so the worker's status can be set to 'Présent', saved, and the success confirmation verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer (Fiche Collaborateur) so the main employee table is accessible, then open the row's presence controls to set the worker to 'Présent' and save (next immediate action: close drawer).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer (if still open) so the main employee table is accessible, then open the first employee's presence controls (Présence) from the table to prepare for setting status to 'Présent'. Next immediate action: click the drawer close button, then open the first employee's presence cell.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[3]/td[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer (if open) so the main employee table is accessible, then open the first employee's presence cell to reveal the status control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[3]/td[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Switch to table view to reveal attendance controls so the worker's status can be set to 'Présent' (click the 'Vue Tableau' button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer so the main employee table is accessible, then open the first employee's presence control from the table to set status to 'Présent' and save (verify success message). Immediate action: close drawer and open first row presence control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[4]/td[7]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer so the main employee table is accessible, then open the first employee's presence control (Présence) from the table to reveal the status selector. Once visible, set the status to 'Présent', save, and verify visible success confirmation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[7]/td[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Wait for the collaborator drawer to finish loading, then open the presence/status controls for the selected worker (MOTEKL WALID) so the status selector becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[7]/td[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Allow drawer to finish loading, close the collaborator drawer, switch to 'Vue Tableau' (table view), open the first employee row/presence cell to reveal the status control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the first employee's presence control (index 2744) to reveal the attendance editor so the status can be set to 'Présent' and saved; then verify a visible success confirmation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[1]/td[4]/span[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator drawer so the main employee table is accessible, then open the first employee's Présence cell to reveal the attendance/status selector (to set to 'Présent' and save). Immediate action: close drawer, then open first row presence control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[3]/td[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Switch the employee list to the table view (Vue Tableau) so the per-day attendance controls become visible, then open the first employee's presence cell to set status.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Présence enregistrée avec succès').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that after selecting a worker, setting their status to 'Présent' and saving, a success confirmation 'Présence enregistrée avec succès' would be visible, but no such confirmation appeared.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Outcome: Verification failed. Objective failure: Presence/status control not found in the collaborator drawer or employee views; attendance status could not be set to 'Présent' and no save/confirmation could be observed. Evidence: collaborator drawer is open for BENNAFAAE MILOUD and repeatedly showed a loading spinner or no status selector despite multiple waits, scrolling and UI interactions (opened/cancelled edit modal, switched views). Steps attempted: waited (3x), scrolled, opened edit modal, clicked 'Annuler' twice, attempted 'Vue Tableau', clicked multiple presence controls in table rows. Blocking issue: presence/status control not present or not rendered (possible UI loading issue, permission restriction, or different workflow required for attendance updates). Recommended next steps for resolution: (1) Navigate to the dedicated \"Feuille de Présence\" (attendance sheet) page if available and try editing there, (2) ensure the UI has finished loading and network requests succeeded (reload the page), (3) check user permissions for modifying attendance, (4) provide the specific steps to access the attendance editor if it is in a different view. Because the UI control to set and save attendance was not found, the requested verification (selecting a worker, setting status to Présent, and seeing a visible success confirmation) could not be completed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254909040392//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.642Z",
    "modified": "2026-02-16T15:15:09.267Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "698ed29a-3689-4fc8-bbf2-49a756c3b68a",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC003-Chef de Chantier saves a new attendance row with Présent status and sees confirmation",
    "description": "Verifies saving a newly created attendance row with status set to Présent results in a visible success message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields on the admin login form and click the 'Connexion Administrateur' button to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar navigation item 'GESTION EMPLOYÉS' to reveal the 'Feuille de Présence' link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open an employee's presence management panel by clicking the 'Présence' area on an employee card (to reach the attendance controls) so a new attendance row can be created and saved.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Présence' section inside the collaborator drawer to reveal attendance controls (date picker / add row). Then wait for the attendance UI to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[1]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the attendance controls by clicking the Présence card inside the collaborator drawer to reveal the add-row / attendance editor UI so a new row can be created.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[1]/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the full profile page for the collaborator (click the 'Profil →' link) to access attendance controls from there.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the full profile for AYADI KL by clicking 'Profil →' (or confirm navigation) and wait for the profile page to load so attendance controls can be located.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historique' tab on the employee profile to reveal attendance/history controls (add-row / attendance table).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reveal the attendance editor/add-row UI on the employee profile so a new attendance row can be created. Start by switching to the 'Informations' tab to look for the presence/attendance editor controls.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate back to the employees list (click 'Retour aux employés') to try an alternative path to the attendance sheet / 'Feuille de Présence' page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Retour aux employés' button to return to the employees list so an alternative path (Feuille de Présence or card-level presence controls) can be used to create the attendance row.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the employees list to try an alternate path to the attendance sheet (click 'GESTION EMPLOYÉS' in the sidebar).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Retour aux employés' to return to the employees list so an alternative path to the attendance sheet or card-level presence controls can be used.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Retour aux employés' to return to the employees list so an alternate path (Feuille de Présence link or card-level Présence controls) can be used to create a new attendance row.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the employees list to try an alternative path to the attendance sheet — click the 'Gestion Employés' sidebar link to navigate to the employees list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the employees list to find an alternate path (Feuille de Présence or card-level presence controls) to create a new attendance row. Click the 'Gestion Employés' sidebar link to navigate to the employees list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Switch the employees view to table/list mode to reveal attendance controls (click the 'Vue Tableau' button) so the attendance add/editor controls can be found.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the AYADI KL employee action (row 'Action' button) to reveal the collaborator drawer or presence controls so the attendance editor can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div/table/tbody/tr[1]/td[7]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Présence enregistrée').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to save a newly created attendance row with status 'Présent' and expected a visible success message ('Présence enregistrée'), but the success message did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task incomplete - attendance creation could not be completed.\n\nSummary of findings and objective failure statements:\n- Drawer for AYADI KL is open and employee profile is reachable (date input index 2589 value=2026-02-16).\n- Attempted to reveal attendance editor by: clicking the 'Présence' tile in the collaborator drawer (2 attempts), opening the full profile via 'Profil →' (2 attempts), switching tabs (Historique/Informations), extensive scrolling, switching to table view and re-opening drawer, and searching the page for 'Ajouter' and 'Feuille de Présence'.\n- Attendance add-row/editor controls (e.g., 'Ajouter', add-row button, status selector, Save) were not found anywhere on the profile/drawer/table views. Attendance creation was therefore not attempted (0 out of 1).\n\nPossible reasons blocking completion (objective statements):\n- Add-row/editor controls are not rendered for this user/account or for this employee (UI permission or feature flag may be off).\n- The attendance editor may be located on a different page (Feuille de Présence) not exposed via visible links in the current UI; previous searches for that link returned no match.\n- The add control may be conditionally visible (requires a specific date context, role, or a different UI state) and that condition was not met.\n\nSuggested next steps (choose one):\n1) Provide the direct navigation target (URL) or where the 'Feuille de Présence' link is expected to be so the assistant can try it (if allowed). Example: the exact sidebar submenu or a specific employee action that reveals the editor.\n2) Provide a screenshot or indicate which exact button should show 'Ajouter' so the assistant can attempt a targeted click (avoiding repeating the same failed interactions).\n3) Confirm that the admin account has the permission to add attendance rows; if not, enable or provide elevated test credentials.\n4) If direct backend/API access is acceptable, provide endpoint or credentials to create a test attendance row so the success message can be observed.\n\nBecause the attendance add-row controls could not be located after multiple distinct approaches, the verification that saving a newly created attendance row shows a visible success message cannot be completed at this time.\n\nIf new instructions are provided (e.g., allow direct navigation to a known Feuille de Présence URL or provide guidance which UI control reveals the editor), further automated steps can be attempted.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254828857319//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.649Z",
    "modified": "2026-02-16T15:13:49.037Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "3b5371ca-71ae-43e8-947d-a33bfea8c5a9",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC004-Edit historical attendance: change a worker from Absent to Présent and save",
    "description": "Verifies a Chef de Chantier can edit an existing date, change a worker’s status from Absent to Présent, save, and see updated state on screen.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin email and password fields and click 'Connexion Administrateur' to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employee/attendance section by clicking 'Gestion Employés' to find 'Feuille de Présence'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Gestion Employés menu to reveal 'Feuille de Présence' (click element 604), then wait briefly for the page/menu to update.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Set the attendance date to a past date using the date input (index 659), then open the Chef de Chantier employee card (index 1420) to edit attendance for that date.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div[2]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-14')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the presence/status control for Chef de Chantier by clicking the presence value (element index 1403) so the status can be changed from 'Absent' to 'Présent'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div/div[2]/div[1]/p[2]/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking 'Modifier', then locate and change attendance/status from 'Absent' to 'Présent' and save. Immediate action: click the 'Modifier' button to enter edit mode.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit form to return to the collaborator panel and reveal the attendance/presence controls so the status can be changed (click 'Annuler' to close the modal).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit form (click 'Annuler' button) so the collaborator panel reveals attendance/status controls to change the status.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking the 'Modifier' button so the attendance/status field can be changed from 'Absent' to 'Présent'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit modal (Annuler) to reveal the collaborator panel, then open the presence/status control to change the worker's attendance from 'Absent' to 'Présent'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[1]/div[1]/span[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking the 'Modifier' button so the attendance/status field becomes editable.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal so the collaborator panel returns to view mode and the attendance/presence controls can be accessed (click 'Annuler' in the modal). After that: open presence/status control for the target date, change Absent -> Présent, save, and verify updated state.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal (Annuler) so the side panel returns to view mode, then open the presence/presence-date control to change status from 'Absent' to 'Présent'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking the 'Modifier' button so the attendance/status field can be edited.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal (click 'Annuler') to return to the collaborator side panel so the attendance/presence controls can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal by clicking the 'Annuler' button so the side panel returns to view mode and the attendance/presence controls can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking the 'Modifier' button so the attendance/status field becomes editable (click element index 2098).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal by clicking the 'Annuler' button so the side panel returns to view mode and the attendance/presence controls can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator edit modal so the side panel returns to view mode and the attendance/presence controls can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit form by clicking 'Modifier' so the attendance/status field becomes editable (click element index 2098).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit modal (Annuler), click the presence/status control for the selected date to change Absent->Présent, then extract/check the page to verify 'Présent' appears.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[6]/div[2]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[1]/div[1]/span[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the collaborator edit modal (Modifier) and extract the modal contents to locate the presence/attendance status control (label, current value, available options) and the Save button index so the status can be changed and saved.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Présent').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to change the worker's status from 'Absent' to 'Présent' for the selected date and save it, but 'Présent' was not visible on the page — the attendance update did not take effect or was not displayed.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results and next steps:\n\nWhat was completed:\n- Logged in as admin (admin@klbeton.tn) and navigated to the employees dashboard for date 2026-02-14.\n- Opened the Chef de Chantier collaborator panel and opened/inspected the edit modal multiple times.\n- Located relevant DOM elements: Modifier (index 3217), date input (index 3254), Annuler (index 3307), Save (index 3308).\n- Extracted visible text: the profile shows \"Présence 0J\" for Chef de Chantier. The text \"Présent\" is NOT present anywhere on the page.\n\nWhat prevented completing the requested change:\n- No per-date presence control (input/select/toggle/button) was found in the collaborator edit modal or elsewhere on the page that would allow changing a single date's status from Absent→Présent. Multiple extraction attempts returned no such control. Because the control to change presence is not present in the current DOM, automatic change and save cannot be performed.\n\nSuggested next steps (pick one):\n1) Navigate to the dedicated \"Feuille de Présence\" (attendance sheet) page where per-date attendance is normally edited, then retry locating the per-date control and perform the change. The sidebar or navigation may contain that link.\n2) If the per-date editing UI is supposed to be inside this collaborator modal, adjust the application to render the per-date presence control in the modal (or provide the selector), then re-run the test.\n3) Provide guidance or confirm where the application exposes the per-date attendance editing (exact page or button) so the automation can be directed there.\n\nCurrent outcome: Task not completed. Status change Absent→Présent NOT performed. Verification NOT done. success=false.\n\nIf the user wants the automation to continue: confirm to (A) open the \"Feuille de Présence\" page now and search for the per-date control, or (B) specify where the per-date presence control is located in the UI. If the user prefers a manual instruction, the next action recommendation is to open the Feuille de Présence page and locate the per-employee cell for 2026-02-14 to toggle Absent→Présent.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254868126409//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.655Z",
    "modified": "2026-02-16T15:14:28.247Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "2b3ca43d-d802-45aa-9459-26944a614b28",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC005-After editing Absent to Présent, save shows confirmation and the updated status remains visible",
    "description": "Verifies that saving an edited attendance sheet shows success and the updated status is reflected on the page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with admin@klbeton.tn (first step of login).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar item that leads to employee management to locate 'Feuille de Présence' (click 'Gestion Employés').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gestion Employés' sidebar item to open employee management and locate 'Feuille de Présence' (index 948).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Set the attendance date picker to a past date (change date input to 2026-02-01) so the page updates to that date's attendance.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div[2]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-01')\n        \n        # -> Open the 'Feuille de Présence' (attendance sheet) for the first employee by clicking the 'Présence' control on the employee card.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the full employee profile page (use 'Profil →') to locate and open the Feuille de Présence attendance sheet.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the full employee profile page by clicking the 'Profil →' link so the 'Feuille de Présence' attendance sheet can be located and opened.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[2]/div[4]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the employees list by clicking 'Retour aux employés' so the attendance sheet ('Feuille de Présence') can be opened from the list and edited.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the employee 'Historique' tab to locate the 'Feuille de Présence' attendance sheet.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Feuille de Présence for 1 February 2026 by clicking the corresponding Historique row (index 3354). Then edit/save and verify 'Success' (subsequent steps after opening).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/table/tbody/tr[3]/td[1]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Historique row for dim. 1 février 2026 (index 3354) to open the Feuille de Présence attendance sheet so it can be edited and saved.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/table/tbody/tr[3]/td[1]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Historique row for dim. 1 février 2026 (index 3354) to open the Feuille de Présence attendance sheet so it can be edited and saved.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/table/tbody/tr[3]/td[1]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try an alternative path to open the attendance editor: change the global attendance date selector (index 2998) to 2026-02-01, wait for the page to update, then scan the page for any editable attendance controls or 'Enregistrer'/'Save'/'Succès' indicators.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/header/div/div[2]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-01')\n        \n        # -> Click 'Retour aux employés' to return to the employees list so the attendance editor can be opened from the employee card (alternative path).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Historique child element (index 3358) for dim. 1 février 2026 to attempt to open the editable Feuille de Présence attendance sheet.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/table/tbody/tr[3]/td[4]/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open an alternative path to the attendance editor by clicking the 'Informations' tab on the profile (index 3138), then scan the resulting content for the attendance editor, 'Enregistrer/Save' button, or 'Success/Succès' indicators.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the employees list (Gestion Employés) to try an alternative path to open the Feuille de Présence attendance editor from the employee card/list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Historique tab area (ensure active), scroll to reveal content, and extract the page for any headings/buttons/text indicating 'Feuille de Présence', 'Enregistrer', 'Sauvegarder', 'Save', 'Succès', 'Success', or related attendance form fields so an alternative path to open the editor can be identified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open an employee's profile page by clicking the card's detail arrow (alternative profile open action) to access the full profile/Historique where the Feuille de Présence editor may be accessible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[9]/div/div[3]/div[2]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile side panel, then try opening the attendance editor from the employee list by clicking the employee's 'Présence' control (use a different presence element index). After that, scan the page for 'Enregistrer/Save' and 'Success/Succès' indicators.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Success').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Saving the edited attendance sheet should display a 'Success' confirmation and the updated status should be reflected on the page, but the 'Success' message did not appear (the save may have failed or the UI did not update).\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task ended - verification failed. Summary of findings and blocking issues:\n- The attendance editor (Feuille de Présence) could not be opened despite multiple navigation attempts and element clicks. Page content extractions show only the Historique table and no editable attendance form fields, no 'Enregistrer'/'Save' button, and no 'Success'/'Succès' message.\n- The Historique row for 01-02-2026 (index 3354) was clicked 3 times with no effect; further clicking of that same element is being avoided to prevent loops. A profile side panel is currently visible with a persistent loading spinner which prevents accessing underlying controls.\n- Because the editor did not open, saving and verification of 'Success' could not be performed.\nRecommended next steps (choose one):\n1) Permit direct navigation to the employee attendance page (go_to_url) so the editor can be opened and the save workflow tested (example URL pattern seen in extracts: /admin/dashboard/employes/{employee-id}?date=2026-02-01). This is the most reliable next step given the SPA navigation issues.\n2) If direct navigation is not allowed, provide a hint about where the 'Feuille de Présence' editor is in the UI (exact menu/button) or allow increasing timeouts to wait for the side panel to finish loading.\nIf user chooses to continue, indicate preference and permission to use a direct URL; the next action will be to navigate there and attempt to open the editor, make an edit, click Save and check for 'Success'.\nCurrent result: success=false (could not verify 'Success').",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254925506825//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.662Z",
    "modified": "2026-02-16T15:15:25.721Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "64358073-6799-47a9-9cc7-5306c079db24",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC006-Admin cannot access Feuille de Présence controls",
    "description": "Verifies an authenticated Admin attempting to open the attendance sheet is denied or cannot see sheet controls.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with admin@klbeton.tn (input index 6).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /employee-login so the admin (already attempted authentication) can attempt to open the attendance sheet from the employee login view.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the employee login page (http://localhost:3000/employee-login) in a new tab so the admin credentials can be used from the employee login view.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the employee login page (http://localhost:3000/employee-login) in a new tab so admin credentials can be used from the employee-login view.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/employee-login (open the employee login page) so the employee login form can be filled with admin credentials.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to http://localhost:3000/employee-login so the employee login form is available to fill with admin credentials.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the employee login page by navigating to http://localhost:3000/employee-login in the current tab so the employee login form can be filled.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the employee login page (/employee-login) in the current tab so the employee login form can be filled with the admin credentials.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /employee-login in the current tab so the employee login form can be used to attempt signing in as admin (or observe access denial).\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the navigation for employee/employee-related pages by clicking 'Gestion Employés' in the sidebar to find the 'Feuille de Présence' (attendance sheet) link or control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gestion Employés' sidebar item to open the employee management area so the 'Feuille de Présence' link/control can be located.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Présence' control for an employee on the Gestion Employés page to attempt opening the attendance sheet and observe whether access is denied or sheet controls appear.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        # Assertion: Verify the \"Access denied\" message is visible\n        access_denied_locator = frame.locator(\"text=Access denied\").nth(0)\n        await page.wait_for_timeout(1000)\n        assert await access_denied_locator.is_visible(), 'Expected \"Access denied\" to be visible but it was not.'\n        \n        # Assertion: Verify the \"Save\" control is not visible\n        save_locator = frame.locator(\"text=Save\").nth(0)\n        await page.wait_for_timeout(500)\n        is_save_visible = await save_locator.is_visible()\n        assert not is_save_visible, 'Expected \"Save\" to not be visible, but it was visible.'\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254558676881//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.668Z",
    "modified": "2026-02-16T15:09:18.818Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "fbd9f59d-fcb3-44e2-ab2a-59e529e1af43",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC007-Validation: saving without selecting a worker shows an error and does not confirm success",
    "description": "Verifies the UI prevents saving when required fields (like worker selection) are missing and shows a visible validation error.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin login form with provided credentials and submit to sign in (fill email, fill password, click 'Connexion Administrateur').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /employee-login to continue the test (access the employee/attendance page).\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the sidebar item 'GESTION EMPLOYÉS' (index 1431) to locate the 'Feuille de Présence' or related attendance page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reveal the submenu or navigation link for 'Feuille de Présence' by interacting with the 'Gestion Employés' sidebar entry (index 1431) to open its submenu.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the attendance (Feuille de Présence) by clicking the 'Présence' control on the first employee card (index 1951).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Présence' control on the first employee card to open the Feuille de Présence (index 1956).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay to reveal the page, then open the 'Présence' control for a different employee to try to access the Feuille de Présence form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then open the 'Présence' control for a different employee to access the Feuille de Présence form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[1]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[3]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then open the Feuille de Présence by clicking a different employee's 'Présence' control to load the attendance form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay so the page and underlying 'Présence' controls are accessible, then open a different employee's 'Présence' to load the Feuille de Présence form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[3]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then open the Feuille de Présence by clicking a 'Présence' control for an employee to load the attendance form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the employee list page to clear the profile overlay, then (after reload) click a different employee's 'Présence' control to open the Feuille de Présence form.\n        await page.goto(\"http://localhost:3000/admin/dashboard/employes?date=2026-02-16\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Présence' control for an employee to open the Feuille de Présence form (attempt the remaining 'Présence' click).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then open a different employee's 'Présence' control to attempt to load the Feuille de Présence form (attendance form).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[9]/div/div[3]/div[2]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay by clicking its close button so the underlying page and 'Présence' controls are accessible (click button index 4134).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then open the Feuille de Présence by clicking a different employee's 'Présence' control to load the attendance form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[4]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the employee list page to clear the collaborator overlay, then (after reload) attempt to open an employee 'Présence' to load the Feuille de Présence form.\n        await page.goto(\"http://localhost:3000/admin/dashboard/employes?date=2026-02-16\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click a 'Présence' control for an employee to open the Feuille de Présence (attendance) form, then wait for the form to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[8]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay so the page is accessible, then open a different employee's 'Présence' to load the Feuille de Présence form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[3]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the employee list to clear the collaborator profile overlay, then click an employee 'Présence' control to attempt to open the Feuille de Présence form.\n        await page.goto(\"http://localhost:3000/admin/dashboard/employes?date=2026-02-16\", wait_until=\"commit\", timeout=10000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click an employee 'Présence' control to attempt to open the Feuille de Présence form (use the remaining presence attempt), then wait for the form to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then click a different employee's 'Présence' control to attempt to load the Feuille de Présence form and wait for it to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div/div[2]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay, then click a 'Présence' control for an employee to attempt opening the Feuille de Présence form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[7]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the employee list page to clear the collaborator profile overlay so the underlying 'Présence' controls are accessible.\n        await page.goto(\"http://localhost:3000/admin/dashboard/employes?date=2026-02-16\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click an employee 'Présence' control to open the Feuille de Présence attendance form, then wait for the form to load so the save validation can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[1]/div/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the collaborator profile overlay by clicking its close button so underlying page and 'Présence' controls are accessible (click element index 7242).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[5]/div[1]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        # Click the \"Save\" / \"Enregistrer\" button to attempt saving without selecting required fields\n        elem = frame.locator(\"xpath=//button[contains(normalize-space(.), 'Save') or contains(normalize-space(.), 'Enregistrer')]\").nth(0)\n        await page.wait_for_timeout(1000); await elem.click(timeout=5000)\n        # Verify the validation message \"Required\" is visible\n        validation = frame.locator(\"text=Required\").nth(0)\n        await validation.wait_for(state='visible', timeout=5000)\n        assert await validation.is_visible()\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254952274743//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.675Z",
    "modified": "2026-02-16T15:15:52.469Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "072ebc6f-9e9f-4fa1-aec0-44feba4c7f06",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC008-Validation: saving with missing required fields keeps the user on the sheet and blocks save",
    "description": "Verifies that when validation fails, the user remains on the attendance sheet and no success confirmation appears.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate to /employee-login so the login form for employees can be used.\n        await page.goto(\"http://localhost:3000/employee-login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the username into the email field (index 155) then type the password (index 156) and submit the form (click index 159).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[1]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[1]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[1]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot continue: sign-in with the provided credentials resulted in an access-denied error on the employee login page, preventing navigation to the attendance sheet.\n\nDetails gathered:\n- Current URL/tab: http://localhost:3000/employee-login\n- Interactive elements visible: email input [155], password input [156], submit button [159]\n- Values filled: email='admin@klbeton.tn' (index 155), password='admin123' (index 156)\n- Clicked element: submit button (index 159) — result: page stayed on employee login and displayed the error message: 'Accès refusé. Veuillez utiliser le portail admin.'\n- 'Feuille de Présence' navigation item not found on the current page, so cannot click it.\n- Because the app did not navigate to the attendance sheet, the assertions required by the test cannot be executed: cannot assert URL contains '/feuille-presence' and cannot verify that the text 'Success' is not visible on that attendance sheet.\n\nConclusion: The validation-failure scenario on the attendance sheet was not reached. success=false.\n\nRecommended next steps:\n- Provide valid employee credentials (non-admin account) so the test can log in to the employee area and continue with: open 'Feuille de Présence', click 'Save', assert URL and absence of 'Success'.\n- Or provide instructions/credentials to access the employee attendance sheet directly (or a test account with appropriate permissions).\n\nIf further action is desired (retry sign-in with other credentials or attempt admin portal), supply credentials or indicate the preferred path.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254270695147//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.682Z",
    "modified": "2026-02-16T15:04:30.812Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "1cd056a8-cd87-4a24-8ca8-82b709338652",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC009-Monthly payroll report calculates base totals using a 26-day working month",
    "description": "Verifies that selecting a month in Admin Rapports shows payroll calculations based on a 26-day base month with per-employee breakdown visible.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin email and password fields and submit the login form to reach the admin dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' link in the left sidebar to open the admin Rapports page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' link in the left sidebar to open the admin Rapports page (use element index 824).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the month selector in the Rapports page to open the month dropdown (element index 1335).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[1]/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the target month 'MARS' from the month dropdown and click 'Générer Rapport' to generate payroll calculations.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254330330911//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.689Z",
    "modified": "2026-02-16T15:05:30.478Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "1d41cc4f-2db2-4d2f-a2c8-723609a42662",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC010-Net salary is floored to zero when advance exceeds earnings and debt is shown",
    "description": "Verifies that for an employee with 1 day worked and a 500 TND advance, net salary shows 0.000 TND and debt to recover shows 500 TND.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password fields and click 'Connexion Administrateur' to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the login form (press Enter) to log in as administrator.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        # -> Click the 'Rapports & Exports' link in the sidebar to open the reports page (use element index 1340).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' link in the sidebar to navigate to the reports page and trigger page change (use element index 1340).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the month selector (index 2025) to ensure correct month is active (FÉVRIER if needed), then click 'Générer Rapport' (index 2052) to generate the report for that month.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[1]/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the employee card/row corresponding to the employee with 1j presence and the 500 TND advance to open details and allow assertions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div[1]/div[1]/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Scroll to the '500' occurrence and click the nearby 'Présences' element to open the employee details so the required texts can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div[1]/div[1]/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Scroll to the visible '500' occurrence and click the nearby 'Présences' element for the corresponding employee to open details for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div[2]/div[1]/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Ensure we are referencing the current page/frame and allow short time for UI updates\n        frame = context.pages[-1]\n        await page.wait_for_timeout(1000)\n        \n        # -> Assertions from the test plan\n        assert await frame.locator(\"text=Net\").is_visible(), \"Expected text 'Net' to be visible\"\n        assert await frame.locator(\"text=0.000 TND\").is_visible(), \"Expected text '0.000 TND' to be visible\"\n        assert await frame.locator(\"text=Dette à recouvrer\").is_visible(), \"Expected text 'Dette à recouvrer' to be visible\"\n        assert await frame.locator(\"text=500\").is_visible(), \"Expected text '500' to be visible\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254631729502//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.696Z",
    "modified": "2026-02-16T15:10:31.890Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "6b73c167-1bcc-470c-b671-407ca697b7c2",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC011-Overtime hourly rate uses (Base/26/8)*1.25 and overtime is added to gross pay",
    "description": "Verifies that an employee with overtime shows an overtime line and the report reflects overtime pay added into gross pay along with the 1.25 multiplier rule.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email and password, then submit the admin login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar link 'Rapports & Exports' to open the reports page (/dashboard/admin/rapports).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar link 'Rapports & Exports' (element index 591) to open the reports page (/dashboard/admin/rapports).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the month selector to open the month options so a month with recorded overtime can be selected (use element index 1226).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[1]/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Générer Rapport' button to generate the report for the currently selected month (FÉVRIER). After the report loads, locate an employee row with overtime to inspect.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254434882034//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.702Z",
    "modified": "2026-02-16T15:07:15.033Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "3e882a2e-5c83-4619-9bec-2adb9aa3f7b5",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC012-Month switching updates payroll figures and employee breakdown refreshes",
    "description": "Verifies that switching between two months updates the visible totals and per-employee calculations rather than showing stale values.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form: enter email and password, then click 'Connexion Administrateur' to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /dashboard/admin/rapports (use direct navigation since no relevant navigation elements are present on the current login page).\n        await page.goto(\"http://localhost:3000/dashboard/admin/rapports\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page and attempt a proper login (fill email and password and submit) so the app can load the dashboard; then proceed to the reports page via the app navigation or direct link if necessary.\n        await page.goto(\"http://localhost:3000/login-admin\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'RAPPORTS & EXPORTS' sidebar link to navigate to the reports page so month switching checks can be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Reports page by clicking the 'Rapports & Exports' sidebar link so month-switch behavior can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the first month (JANVIER) from the month dropdown (element index 2278) and generate the report.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select a different month (FÉVRIER), generate the report, then extract the key totals and first-employee salary to confirm values changed from JANVIER (ensure the UI updates rather than showing stale values).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254445377864//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.709Z",
    "modified": "2026-02-16T15:07:25.533Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "2828f20e-cfca-42c4-a829-7cb13d85e011",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC013-Per-employee report shows daily calculation and overtime calculation sections",
    "description": "Verifies that opening an employee report shows separate visible sections/labels for daily work calculation and overtime calculation with monetary amounts displayed.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin email and password fields and click the 'Connexion Administrateur' button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' sidebar link to open the reports page (use element index 955).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' sidebar link (index 955) again to open the reports page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the month selector to open the month dropdown (element index 1452), then generate the report (element index 1479) to populate employee reports.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[1]/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254407360786//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.715Z",
    "modified": "2026-02-16T15:06:47.520Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "a38952da-f860-4803-8bb5-7856dabb19df",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC014-Negative salary handling shows debt field when net would be negative",
    "description": "Verifies that when deductions (such as advances) exceed gross, the UI displays a debt-to-recover field and does not show a negative net amount.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin login form and submit to authenticate, then proceed to navigate to the rapports page.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the admin login form (email + password) and submit (press Enter) to authenticate, then proceed to the rapports page once logged in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        # -> Click the 'RAPPORTS & EXPORTS' link in the sidebar to navigate to the rapports page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' sidebar link (interactive element index 1193) to navigate to the rapports page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the month selector to open the month dropdown (element 1714), then generate the report by clicking 'Générer Rapport' (element 1741).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/div[1]/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click an employee card/row to open the employee detail panel (use element index 1997) and extract page text to search for 'Dette à recouvrer', 'Net', '-' (minus sign), and 'TND'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div[1]/div[1]/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click another employee row to open its detail panel (element 2044) and then extract/search page content for 'Dette à recouvrer', 'Net', '-' (minus sign), and 'TND'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div[3]/div[2]/div[2]/div[1]/div[2]/div[1]/p[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dette à recouvrer').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected 'Dette à recouvrer' to be visible indicating that deductions (e.g., advances) exceed gross and the UI should display a debt-to-recover field instead of a negative net amount; the label was not found.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary (stopping as requested):\n\nWhat was done:\n- Logged in as admin and opened Rapports & Paie.\n- Selected month JANVIER and generated the report.\n- Opened employee rows (two attempts) and searched page content.\n\nFindings (evidence from page content):\n- \"Dette à recouvrer\": NOT FOUND anywhere in the report or employee details extracted.\n- \"Net\": VISIBLE. Examples: \"Salaire Net Mensuel 121.154TND (HARRABIali)\", \"Salaire Net Mensuel 110.577TND (BENNAFAAEmiloud)\", etc.\n- '-' (minus sign): VISIBLE in Absences lines (these show negative absence amounts). Examples: \"Absences: -1,346.154 TND (HARRABIali)\", \"Absences: -961.538 TND (BENNAFAAEmiloud)\", \"Absences: -1,730.769 TND (AYADIkl)\", etc.\n- \"TND\": VISIBLE next to many monetary fields (evidence listed above).\n\nInterpretation vs. expected behaviour:\n- Expected: when deductions (advances/absences) exceed gross, the UI should display a \"Dette à recouvrer\" (debt-to-recover) field and should not show a negative net amount.\n- Observed: \"Dette à recouvrer\" is not displayed. Net amounts remain non-negative in the displayed summary (so the UI does not show a negative net), while large negative values appear on the \"Absences\" lines. Thus the UI does not surface a \"Dette à recouvrer\" label even when deductions exceed gross (assertion FAILED). The UI also does not display a negative net value (assertion about negative net PASSED). The presence of minus signs in Absences lines means the '-' not-visible assertion (interpreted globally) FAILED.\n\nConclusion:\n- Overall success: false. The critical requirement that a \"Dette à recouvrer\" field appear when deductions exceed gross was NOT met (no such label found). Net is not negative (good), but negative values are still shown on Absences lines and no debt indicator is present.\n\nSuggested next steps (optional, not executed because user requested stop):\n- Open individual employee full detail view (if exists as modal) or expand additional details to check for hidden debt indicators.\n- Check other months or generate a report after applying a manual advance/deduction test fixture to force a clear case of deduction > gross and re-check.\n\nFiles extracted during the run: extracted_content_0.md, extracted_content_1.md\n\n\nAttachments:\n\nextracted_content_0.md:\n<url>\nhttp://localhost:3000/admin/dashboard/rapports?date=2026-02-16\n</url>\n<query>\nFind text 'Dette à recouvrer', 'Net', '-' (minus sign), and 'TND' on the current page (including any newly opened employee detail). Return the matching lines or surrounding text where each appears and indicate if any of them are not found.\n</query>\n<result>\nDette à recouvrer: NOT FOUND on the page.\n\nNet:\n- Masse Salariale Net 1041.707DT\n- Salaire Net Mensuel 121.154TND\n- Salaire Net Mensuel 110.577TND\n- Salaire Net Mensuel 220.673TND\n- Salaire Net Mensuel 113.582TND\n- Salaire Net Mensuel 176.923TND\n- Salaire Net Mensuel 59.495TND\n- Salaire Net Mensuel 0TND\n- Salaire Net Mensuel 129.808TND\n- Salaire Net Mensuel 59.495TND\n- Salaire Net Mensuel 50TND\n\nMinus sign (\"-\") occurrences (lines containing a leading minus for negative values):\n- Absences: -1,346.154 TND\n- Absences: -961.538 TND\n- Absences: -1,730.769 TND\n- Absences: -961.538 TND\n- Absences: -1,538.462 TND\n- Absences: -961.538 TND\n- Absences: -0 TND\n- Absences: -1,442.308 TND\n- Absences: -961.538 TND\n- Absences: -769.231 TND\n\nTND (all lines containing \"TND\"):\n- Salaire Net Mensuel 121.154TND\n- Journalier: 53.85 TND\n- Horaire: 6.73 TND\n- H. Supp: +67.308 TND\n- Absences: -1,346.154 TND\n- Salaire Net Mensuel 110.577TND\n- Journalier: 38.46 TND\n- Horaire: 4.81 TND\n- H. Supp: +72.115 TND\n- Absences: -961.538 TND\n- Salaire Net Mensuel 220.673TND\n- Journalier: 69.23 TND\n- Horaire: 8.65 TND\n- H. Supp: +151.442 TND\n- Absences: -1,730.769 TND\n- Salaire Net Mensuel 113.582TND\n- Journalier: 38.46 TND\n- Horaire: 4.81 TND\n- H. Supp: +75.12 TND\n- Absences: -961.538 TND\n- Salaire Net Mensuel 176.923TND\n- Journalier: 61.54 TND\n- Horaire: 7.69 TND\n- H. Supp: +115.385 TND\n- Absences: -1,538.462 TND\n- Salaire Net Mensuel 59.495TND\n- Journalier: 38.46 TND\n- Horaire: 4.81 TND\n- H. Supp: +21.034 TND\n- Absences: -961.538 TND\n- Salaire Net Mensuel 0TND\n- Journalier: 0.00 TND\n- Horaire: 0.00 TND\n- H. Supp: +0 TND\n- Absences: -0 TND\n- Salaire Net Mensuel 129.808TND\n- Journalier: 57.69 TND\n- Horaire: 7.21 TND\n- H. Supp: +72.115 TND\n- Absences: -1,442.308 TND\n- Salaire Net Mensuel 59.495TND\n- Journalier: 38.46 TND\n- Horaire: 4.81 TND\n- H. Supp: +21.034 TND\n- Absences: -961.538 TND\n- Salaire Net Mensuel 50TND\n- Journalier: 30.77 TND\n- Horaire: 3.85 TND\n- H. Supp: +19.231 TND\n- Absences: -769.231 TND\n\nNotes:\n- \"Masse Salariale Net 1041.707DT\" contains \"Net\" but uses \"DT\" (not \"TND\").\n- \"Dette à recouvrer\" was not found in the provided page content.\n- If more page content is available (truncated), use start_from_char to continue.\n</result>\n\nextracted_content_1.md:\n<url>\nhttp://localhost:3000/admin/dashboard/rapports?date=2026-02-16\n</url>\n<query>\nFind text 'Dette à recouvrer', 'Net', '-' (minus sign), and 'TND' on the current page (including any newly opened employee detail). Return the matching lines or surrounding text where each appears and indicate if any of them are not found.\n</query>\n<result>\nDette à recouvrer: NOT FOUND\n\nNet:\n- Masse Salariale Net 1041.707DT\n- Salaire Net Mensuel 121.154TND (HARRABIali)\n- Salaire Net Mensuel 110.577TND (BENNAFAAEmiloud)\n- Salaire Net Mensuel 220.673TND (AYADIkl)\n- Salaire Net Mensuel 113.582TND (BEN AHMEDmustapha)\n- Salaire Net Mensuel 176.923TND (MOTEKLwalid)\n- Salaire Net Mensuel 59.495TND (MOUSSAwalid)\n- Salaire Net Mensuel 0TND (ChefChantier)\n- Salaire Net Mensuel 129.808TND (HARAABIbechir)\n- Salaire Net Mensuel 59.495TND (SAMIrajeh)\n- Salaire Net Mensuel 50TND (MOUSSAABDELAZIZ)\n\n'-' (minus sign) — lines containing a minus:\n- Absences: -1,346.154 TND (HARRABIali)\n- Absences: -961.538 TND (BENNAFAAEmiloud)\n- Absences: -1,730.769 TND (AYADIkl)\n- Absences: -961.538 TND (BEN AHMEDmustapha)\n- Absences: -1,538.462 TND (MOTEKLwalid)\n- Absences: -961.538 TND (MOUSSAwalid)\n- Absences: -0 TND (ChefChantier)\n- Absences: -1,442.308 TND (HARAABIbechir)\n- Absences: -961.538 TND (SAMIrajeh)\n- Absences: -769.231 TND (MOUSSAABDELAZIZ)\n\nTND — all matching lines / surrounding text:\n- Salaire Net Mensuel 121.154TND (HARRABIali)\n- Journalier: 53.85 TND (HARRABIali)\n- Horaire: 6.73 TND (HARRABIali)\n- H. Supp: +67.308 TND (HARRABIali)\n- Absences: -1,346.154 TND (HARRABIali)\n\n- Salaire Net Mensuel 110.577TND (BENNAFAAEmiloud)\n- Journalier: 38.46 TND (BENNAFAAEmiloud)\n- Horaire: 4.81 TND (BENNAFAAEmiloud)\n- H. Supp: +72.115 TND (BENNAFAAEmiloud)\n- Absences: -961.538 TND (BENNAFAAEmiloud)\n\n- Salaire Net Mensuel 220.673TND (AYADIkl)\n- Journalier: 69.23 TND (AYADIkl)\n- Horaire: 8.65 TND (AYADIkl)\n- H. Supp: +151.442 TND (AYADIkl)\n- Absences: -1,730.769 TND (AYADIkl)\n\n- Salaire Net Mensuel 113.582TND (BEN AHMEDmustapha)\n- Journalier: 38.46 TND (BEN AHMEDmustapha)\n- Horaire: 4.81 TND (BEN AHMEDmustapha)\n- H. Supp: +75.12 TND (BEN AHMEDmustapha)\n- Absences: -961.538 TND (BEN AHMEDmustapha)\n\n- Salaire Net Mensuel 176.923TND (MOTEKLwalid)\n- Journalier: 61.54 TND (MOTEKLwalid)\n- Horaire: 7.69 TND (MOTEKLwalid)\n- H. Supp: +115.385 TND (MOTEKLwalid)\n- Absences: -1,538.462 TND (MOTEKLwalid)\n\n- Salaire Net Mensuel 59.495TND (MOUSSAwalid)\n- Journalier: 38.46 TND (MOUSSAwalid)\n- Horaire: 4.81 TND (MOUSSAwalid)\n- H. Supp: +21.034 TND (MOUSSAwalid)\n- Absences: -961.538 TND (MOUSSAwalid)\n\n- Salaire Net Mensuel 0TND (ChefChantier)\n- Journalier: 0.00 TND (ChefChantier)\n- Horaire: 0.00 TND (ChefChantier)\n- H. Supp: +0 TND (ChefChantier)\n- Absences: -0 TND (ChefChantier)\n\n- Salaire Net Mensuel 129.808TND (HARAABIbechir)\n- Journalier: 57.69 TND (HARAABIbechir)\n- Horaire: 7.21 TND (HARAABIbechir)\n- H. Supp: +72.115 TND (HARAABIbechir)\n- Absences: -1,442.308 TND (HARAABIbechir)\n\n- Salaire Net Mensuel 59.495TND (SAMIrajeh)\n- Journalier: 38.46 TND (SAMIrajeh)\n- Horaire: 4.81 TND (SAMIrajeh)\n- H. Supp: +21.034 TND (SAMIrajeh)\n- Absences: -961.538 TND (SAMIrajeh)\n\n- Salaire Net Mensuel 50TND (MOUSSAABDELAZIZ)\n- Journalier: 30.77 TND (MOUSSAABDELAZIZ)\n- Horaire: 3.85 TND (MOUSSAABDELAZIZ)\n- H. Supp: +19.231 TND (MOUSSAABDELAZIZ)\n- Absences: -769.231 TND (MOUSSAABDELAZIZ)\n</result>",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254574663864//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.722Z",
    "modified": "2026-02-16T15:09:34.787Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "4ca088c8-2964-4af2-842b-65142589871b",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC015-Admin can access Reports dashboard and see real-time chart widgets",
    "description": "Verifies an authenticated admin can open the reports page and sees the key real-time chart/summary sections.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field with admin@klbeton.tn (index 70), then fill the password field with admin123 (index 79), and click the 'Connexion Administrateur' submit button (index 80).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' navigation item to open the reports page and then verify URL and presence of 'Attendance' and 'Overtime' sections.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' navigation item (index 803) to open the reports page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Attendance').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After signing in as an admin and opening the Reports page (/dashboard/admin/rapports), the test expected the 'Attendance' section to be visible but it was not found — the reports page did not render the expected real-time Attendance summary.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification attempt:\n- Current page URL: http://localhost:3000/admin/dashboard/rapports?date=2026-02-16\n- URL contains '/dashboard/admin/rapports': No (actual path is '/admin/dashboard/rapports')\n- Text 'Attendance': Not present/visible on page\n- Text 'Overtime': Not present/visible on page\n- Visible prominent text: 'EN ATTENTE DE CALCULS' (placeholder message), located center/middle of page\n- Actions performed: authenticated as admin (email admin@klbeton.tn), opened 'Rapports & Exports' (clicked index 803 twice), scrolled down multiple times but report sections not revealed\nConclusion: The reports page is reachable but the expected real-time chart/summary sections ('Attendance' and 'Overtime') are not visible; verification failed. Likely a report-generation or data-availability state ('En attente de calculs') is blocking display of those sections. No further actions requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254356727403//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.729Z",
    "modified": "2026-02-16T15:05:56.862Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "e83815f9-2126-4b50-8898-3b1e03ceb324",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC016-Admin reports page shows financial summary section",
    "description": "Verifies the reports page includes a visible financial summary area for admins.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter admin credentials into the email and password fields and click the 'Connexion Administrateur' submit button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sign-in button on the login page to attempt login again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/div[2]/div/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Connexion Administrateur' submit button (element index 10) to attempt login again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' navigation item to open the reports page (use element index 785).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' navigation item to open the reports page (use element index 785).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254292228587//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.735Z",
    "modified": "2026-02-16T15:04:52.355Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "b5416e80-4fe9-44b0-aeaf-dd6be9496a95",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC017-Non-admin user cannot access admin reports (access denied or redirected)",
    "description": "Verifies a non-admin account is blocked from viewing the admin reports page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill email with nonadmin.user@example.com, fill password with WrongPassword123!, then click the 'Connexion Administrateur' (submit) button to sign in as the non-admin account.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('nonadmin.user@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('WrongPassword123!')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /dashboard/admin/rapports and check the page for the text 'Access denied'.\n        await page.goto(\"http://localhost:3000/dashboard/admin/rapports\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access denied').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected a non-admin user to be blocked from viewing the admin reports page — the 'Access denied' message did not appear after navigating to /dashboard/admin/rapports\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of test and findings:\n- Actions performed: navigated to /login-admin, entered email 'nonadmin.user@example.com' and password 'WrongPassword123!', clicked 'Connexion Administrateur', then navigated to /dashboard/admin/rapports.\n- Observed page content: '404' and 'This page could not be found.' The exact text 'Access denied' was not found on the page.\n- Important note: the provided password was incorrect, so the session is not authenticated as the non-admin user. Because of that, inability to access the reports page cannot be conclusively attributed to non-admin authorization; the 404 may indicate a missing route or an unauthenticated redirect.\n- Conclusion: Verification incomplete. The specific assertion 'Access denied' failed (not present).\n- Recommendation: Re-run the test while logged in with valid non-admin credentials (or supply correct non-admin password). For a definitive check, log in as the non-admin user, then navigate to /dashboard/admin/rapports and confirm whether an 'Access denied' (or localized equivalent) message appears. Alternatively, test with the provided admin credentials to compare behavior.\nResult: success=false (test inconclusive).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254251983337//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.742Z",
    "modified": "2026-02-16T15:04:12.134Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "e1206ef5-b169-43c3-b5e7-537ac72686df",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC018-Reports page shows key report controls when opened by admin",
    "description": "Verifies the reports page exposes controls for Global Recap and Individual PDF generation to an authenticated admin.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the admin credentials into the email and password fields and click the 'Connexion Administrateur' (sign in) button to authenticate.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Connexion Administrateur' button (index 10) to submit the login form and wait for navigation to the admin dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' item in the sidebar to open the reports page, then verify the three required texts are present.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Rapports & Exports' sidebar item (index 1055) to open the Reports page so the required texts can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Global Recap').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected 'Global Recap' to be visible on the Reports page after logging in and navigating to Rapports; this verifies the presence of the Global Recap control for PDF generation, but the element was not found — the reports page may not have loaded, navigation/authentication may have failed, or the control is missing\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification result: Controls for 'Global Recap', 'Generate PDF', and 'Generate Individual PDF' were NOT found on the Reports page for the authenticated admin. Visible report UI elements: month selector (index 1560, showing 'FÉVRIER'), year input (index 1582, value 2026), and a 'Générer Rapport' button (index 1587). The page displays 'EN ATTENTE DE CALCULS' and requests a period selection. Conclusion: The specific global-recap and individual-PDF controls are not exposed in the current page/DOM. success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254353473957//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.752Z",
    "modified": "2026-02-16T15:05:53.684Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "8a08370c-b371-488c-9b92-f5def85470dc",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC019-Authenticated user can open inbox and see messages loaded",
    "description": "Verifies that a logged-in user can access the inbox UI and sees messages displayed after they load.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email field (index 70) with admin@klbeton.tn, then fill the password field (index 79) with admin123, then click the Sign in button (index 80).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Messages' item in the left navigation to open the inbox UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Messages' item in the left navigation to open the inbox (element index 1339). After the click, verify the page title contains 'Messages' and that the message list is visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions appended after interactions\n        assert \"/\" in page.url, f\"Unexpected URL after sign in: {page.url}\"\n        \n        # Verify the page title contains 'Messages'\n        title = await page.title()\n        assert \"Messages\" in title, f\"Expected 'Messages' in page title, got: {title}\"\n        \n        # Verify that message items are displayed in the inbox UI by waiting for a known message text from the page content\n        await page.wait_for_selector(\"text=bonjour\", timeout=10000)\n        msg = page.locator(\"text=bonjour\").nth(0)\n        assert await msg.is_visible(), \"Expected a message item (text 'bonjour') to be visible in the inbox UI\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254291678325//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.760Z",
    "modified": "2026-02-16T15:04:51.803Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "91750c16-ffe1-4764-a8d1-9a85c5acfba2",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC020-Authenticated user sees message details when opening a message",
    "description": "Verifies that a logged-in user can open a message from the inbox and view its content.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields with provided credentials and click the 'Connexion Administrateur' button to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Messages' (Inbox) link in the main navigation to open the message list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Messages' (Inbox) link in the sidebar to open the message list (use element index 1479).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254276026335//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.766Z",
    "modified": "2026-02-16T15:04:36.178Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "1a4eed92-e173-4629-8895-a8f7e8f861d0",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC021-Authenticated user sees empty state when there are no messages",
    "description": "Verifies that the inbox UI shows a clear empty state when no messages are available.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the email and password fields and click the 'Connexion Administrateur' (submit) button to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Messages' in the sidebar to open the Messages/Inbox view, then verify the page title and look for the empty-state text.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Messages' link in the sidebar to open the Messages/Inbox view and then check for the page title and empty-state text.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254265508929//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.773Z",
    "modified": "2026-02-16T15:04:25.678Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "7a8f4fe3-8633-406d-802d-426be4764d41",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC022-Prisma migration completes successfully and application boots connected to PostgreSQL",
    "description": "Verifies the system can complete a database migration and then boot normally with a working DB connection.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to log in as administrator to trigger any DB migration or surface DB connection errors: fill the email and password fields and click 'Connexion Administrateur', then observe resulting page text for 'Database' or 'Error' messages.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Migration completed successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the application to complete the database migration and boot with a working DB connection (visible text 'Migration completed successfully'), but that success message did not appear, indicating the migration or DB connection likely failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification and results:\n\n- Action evidence:\n  - Navigation: The application navigated to /admin/dashboard?date=2026-02-16 after the login attempt (dashboard is currently visible).\n  - Visible UI: Dashboard elements and values are shown (e.g., 'TAUX PRESENCE (MOIS) 6%', 'EMPLOYÉS ACTIFS 10', 'H. SUPP (MOIS) 30h', and other dashboard widgets), and sidebar navigation is present.\n  - Title/heading: The site title/heading contains 'KL BETON' (matches the assertion about 'KL Beton').\n\n- Keyword search results (case-insensitive) on the visible page text: 'Database', 'Error', 'migration', 'migrate', 'migrating', 'migration completed', 'DB connection', 'connection refused', 'boot', 'started', 'success', 'failed' -> NO occurrences found. No lines with those keywords were present in the visible page text.\n\n- Interpretation against the requested verification:\n  - Can the system boot normally with a working DB connection? EVIDENCE FOR: The application reached and rendered the admin dashboard and displayed data (employee counts and other metrics). This behavior strongly indicates the backend started and is serving data (DB connection appears functional from the observable UI). EVIDENCE AGAINST: No explicit message confirming DB connection success is present on the page. Overall assessment: boot and working DB connection: likely SUCCESS based on dashboard load and data display.\n  - Can the system complete a database migration (and show migration completion)? RESULT: NO EVIDENCE observed. The page does not show any migration messages (success or failure). Migration completion could have occurred silently, or might require running migration commands or checking server logs; the web UI does not display migration status.\n\n- Final explicit answers for the original assertions:\n  1) Page title/main heading contains 'KL Beton'?: YES (visible heading/title includes 'KL BETON').\n  2) Visible page text contains the exact word 'Login'?: NO (case-insensitive search returned no match).\n  3) Visible page text contains the word 'Database'?: NO.\n  4) Visible page text contains the word 'Error'?: NO.\n\n- Discrepancy noted: The browser tab title contains 'KL Beton - Système de Pointage' while the main visible heading reads 'KL BETON' (capitalization/formatting difference, expected and observed but not harmful).\n\n- Conclusion and recommended next steps:\n  - Conclusion: The application appears to have booted and is serving the admin dashboard, which implies the DB connection is functioning. There is no visible confirmation of database migration having run or completed on the UI. Therefore the user's request to \"verify the system can complete a database migration and then boot normally with a working DB connection\" is only partially verifiable from the UI: boot and DB usage appear successful; explicit migration completion cannot be confirmed from the visible page.\n  - Recommendation: To conclusively verify database migrations, check server logs or the backend migration command output (e.g., run the migration command on the server or inspect migration table/status in the database). If access to server logs or the database is not available via the UI, run migrations manually on the host or expose migration results where they can be observed.\n\nResult: overall success=false (migration completion not confirmed via UI; boot/DB connection likely OK).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/177125434016702//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.779Z",
    "modified": "2026-02-16T15:05:40.368Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "e70b9db5-1138-4b0c-a4ee-f81c6f6732de",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC023-Migration conflict results in deployment halt with visible migration error information",
    "description": "Verifies that when a migration fails due to a conflicting schema, the deployment/run surface shows an error state to the operator/admin.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the admin email into the email input (index 70).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Connexion Administrateur' button (index 80) to submit the login and allow the app to navigate; then check for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate from the dashboard to the likely area showing migration/deployment errors by clicking the 'Paramètres' menu item to look for 'Migration' or 'failed' messages.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Paramètres' menu item to open the settings area, then search the settings page for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar item 'Rapports & Exports' (index 1340) to open that section and search the page for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar item 'Rapports & Exports' (index 1340) to open that section and then search the opened page for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the admin/welcome menu to look for migration/deployment logs or pages (click the top admin/welcome button) and then search for 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar 'settings' (gear) item to open settings/migration area, then search the opened page for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open a different sidebar section that may contain migration/deployment logs by clicking the sidebar link (index 1336), then search the opened page for the text 'Migration'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click a different sidebar item (index 1338) that was not tried recently, then search the opened page for the text 'Migration' and, if not found, for the text 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click a different sidebar item (index 1339) to open another section that may show migration/deployment errors; after the page updates, search for 'Migration' and then for 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar item at index 1341 to open a different section that may contain migration/deployment logs, then search that section for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the unused sidebar link at index 1337 to open a different section that may contain migration/deployment logs, then (after navigation) search that page for 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the admin avatar/welcome menu by clicking button index 1364, then search the opened menu/page for the texts 'Migration' and 'failed'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the admin email into the email input (index 4127) and proceed to enter password and submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result summary and stopping status:\n\n- What was attempted: Navigated to the app and the /login page, entered admin credentials (admin@klbeton.tn / admin123), and signed in (2 clicks + Enter). Once authenticated, the admin dashboard was explored: the dashboard, Paramètres (settings), Rapports & Exports, profile, finances, messages and several other sidebar sections were opened and searched.\n\n- What was expected: Verify that when a migration fails due to a conflicting schema the UI shows an error state containing the text 'Migration' and 'failed'.\n\n- What was observed: The admin dashboard loaded successfully and multiple sections were opened. Repeated searches (7 attempts each) for the texts 'Migration' and 'failed' across the visible admin UI returned no matches. No migration error surface or messages containing those strings were visible on any pages visited.\n\n- Conclusion: Verification failed. The UI elements or texts required to confirm that a migration failure is shown to the operator/admin were not found during this test run.\n\n- Recommended next steps for the tester/operator:\n  1) Confirm that the environment contains a failed migration instance (backend/state) to trigger the UI error. If the failure must be simulated, reproduce the conflicting-schema migration on the backend.\n  2) If a specific admin page shows migration/deployment status, provide its exact navigation path or URL so the test can navigate there directly.\n  3) Check server logs or API responses for migration error endpoints to see if the frontend receives an error but does not display it.\n  4) If the UI is expected to show migration errors only in a particular role/feature flag or on a different admin instance, ensure the test account has the required permissions and the feature is enabled.\n\n- Final status: success=false. The verification could not be completed because the required UI texts were not found.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254660164212//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.786Z",
    "modified": "2026-02-16T15:11:00.304Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "65ab3fc4-6dc4-4a46-a62c-0d9fdad23411",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC024-Invalid DB credentials cause operational error surfaced to admins",
    "description": "Verifies that when database credentials are invalid, the UI shows an operational error to admins rather than silently failing.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the admin email into the email field (index 70)\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the main navigation item that leads to Attendance (click 'Gestion Employés' / index 568) to open the Attendance page and then search that page for the texts 'Database connection error' and 'Try again'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Gestion Employés' (index 568) to open the Attendance page, wait for navigation, then search that page for the exact texts 'Database connection error' and 'Try again' and return any matches with surrounding context.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Database connection error').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the admin UI to display 'Database connection error' when database credentials are invalid so administrators are informed of the operational issue, but the message did not appear — the app may be failing silently instead of reporting the error\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of findings:\n- Performed login with provided admin credentials and navigated to the 'Gestion Employés' (employees) page.\n- Searched both the dashboard and the employees page for the exact texts \"Database connection error\" and \"Try again\".\n- Neither string was present on the dashboard nor on the employees page.\nConclusion:\n- The UI did not display the expected operational error texts in this session. However, the environment did not simulate or trigger an \"invalid database credentials\" condition at the backend, so the specific behavior requested (UI response when DB credentials are invalid) could not be fully validated.\nRecommended next steps to complete verification:\n1) Reproduce an invalid-DB-credentials condition on the server ( temporarily misconfigure DB credentials or force DB connection failure ), then reload the admin UI and verify whether an operational error banner/modal/toast appears for admins. \n2) Alternatively, instrument the backend to return a DB-connection error response to admin-facing endpoints, then check the UI for an error message.\n3) Check server logs or API responses for error details if reproducing on the backend is not possible from the UI alone.\nIf assistance is required to attempt a frontend-level simulation (e.g., intercept API responses or toggle a feature flag) or to run additional checks after a backend change, provide instructions or the capability and the steps will be executed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/177125429660674//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.792Z",
    "modified": "2026-02-16T15:04:56.741Z"
  },
  {
    "projectId": "68df0ab8-c7d6-4591-a0e4-71ff017e539f",
    "testId": "d1daba02-6bb9-4f20-b7d0-601d5136cee8",
    "userId": "64f874b8-c021-7015-ea4e-4368e055b5b4",
    "title": "TC025-Attendance query succeeds when DB connection is healthy (no operational error shown)",
    "description": "Verifies attendance data can be queried through Prisma without showing DB operational errors under normal conditions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type the admin email into the email field (index 7), then type the password (index 8), then click the Sign in button (index 11).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@klbeton.tn')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Gestion Employés' in the sidebar to navigate toward the Attendance section (element index 942). After navigation, locate and click the actual 'Attendance' item if needed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Gestion Employés' sidebar item to reveal its submenu and locate/select the 'Attendance' item (then verify attendance element and absence of DB error).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/64f874b8-c021-7015-ea4e-4368e055b5b4/1771254298218443//tmp/test_task/result.webm",
    "created": "2026-02-16T15:02:21.799Z",
    "modified": "2026-02-16T15:04:58.365Z"
  }
]
